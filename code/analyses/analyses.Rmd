---
title: "Assessing the replicability of decisions based on Cronbach's-alpha-if-item-removed"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# TODO

- NA

```{r, include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      warning=FALSE)
```

```{r}

# dependencies
library(tidyverse)
library(knitr)
library(kableExtra)
library(psych)
library(lme4)
library(sjPlot)
#library(emmeans)
library(marginaleffects)
library(janitor)
library(boot)
library(Cairo)

# create necessary directories
dir.create("../../data/results")

# functions
# rounds all numeric variables in a dataframe to the desired number of places. Non-numeric variables will be ignored.
round_df <- function(df, digits) {
  mutate_if(df, is.numeric, janitor::round_half_up, digits = 2)
}

# set up parallel processing
future::plan(multisession)

# set seed for reproducibility
set.seed(42)

```

# Data

```{r}

data_nested_single_timepoint <- read_rds("../../data/processed/data_nested_single_timepoint.rds")

data_drop_decisions_no_data <- read_rds("../../data/results/data_drop_decisions_no_data.rds") |>
  mutate(sample_size                   = as.factor(subset_n_per_split),
         match_item_if_dropped         = as.factor(match_item_if_dropped),
         match_item_if_dropped_or_none = as.factor(match_item_if_dropped_or_none))

```

# Full sample metrics

These are already established scales, many of which are well known, with a reasonable range of Cronbach's $\alpha$ values when calculated in a large sample. The subsequent assessment of the replicability of item-dropping recommendations is therefore likely generalizable. 

```{r}

cronbachs_alpha <- function(data){
  psych::alpha(data)$total["raw_alpha"]
}

results_overall <- data_nested_single_timepoint |> 
  mutate(results = furrr::future_map(data, 
                                     cronbachs_alpha, 
                                     .options = furrr_options(seed = TRUE))) |>
  unnest(results) |> 
  mutate(n = furrr::future_map(data, nrow, .options = furrr_options(seed = TRUE))) |>
  unnest(n)

results_overall |>
  select(scale, alpha = raw_alpha, n) |>
  round_df(2) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

results_overall |>
  select(scale, alpha = raw_alpha, n) |>
  summarize(k_scales       = n(),
            N_participants = sum(n),
            alpha_min      = min(alpha),
            alpha_max      = max(alpha),
            alpha_mean     = mean(alpha),
            alpha_sd       = sd(alpha)) |>
  round_df(2) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

# lm(raw_alpha ~ 1, weights = n, data = results_overall)
weighted_average <- janitor::round_half_up(weighted.mean(results_overall$raw_alpha), 2)

```

Weighted average $\alpha$ = `r weighted_average`.

# Frequency of item drop recommendations

```{r fig.height=12, fig.width=10}

data_n_items <- data_nested_single_timepoint |>
  mutate(n_items_in_scale = as.numeric(map(data, ncol))) |>
  select(-data)

data_drop_decisions_no_data |>
  distinct(scale, item_to_drop_a) |>
  count(scale) |>
  rename(n_distinct_items_with_drop_recommendations = n) |>
  left_join(data_n_items, by = "scale") |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

p_freq <- 
  data_drop_decisions_no_data |>
  count(scale, item_to_drop_a) |>
  arrange(scale, desc(n)) |>
  group_by(scale) |>
  mutate(item_rank = paste("ranked_item_", row_number(), sep = ""),
         item_rank = fct_reorder(item_rank, n, .desc = TRUE)) |>
  ungroup() |>
  select(-item_to_drop_a) |>
  # pivot_wider(values_from = n,
  #             names_from = item_rank) |>
  ggplot(aes(item_rank, n)) +
  geom_bar(stat = "identity") +
  scale_x_discrete(labels = seq(from = 1, to = max(data_n_items$n_items_in_scale), by = 1)) +
  facet_wrap(~scale, ncol = 3) +
  xlab("Item ranked by number of drop recommendations") +
  ylab("Number of drop recommendations") +
  theme_light()

p_freq

ggsave(filename  = "../plots/drop_recommendation_frequencies.pdf",
       plot      = p_freq,
       device    = "pdf",
       units     = "in",
       width     = 10,
       height    = 12,
       limitsize = TRUE)

```

# Multilevel logistic regressions

## Proportion of pairs of samples with matching item-drop recommendation

```{r}

# fit model
fit_1 <- 
  glmer(match_item_if_dropped ~ 1 + sample_size + (1 | scale),
        family = binomial(link = "logit"),
        data = data_drop_decisions)

# marginal means
results_1_estimates <- fit_1 |>
  marginalmeans() |>
  tidy() |>
  filter(term == "sample_size") |>
  select(sample_size = value, estimate, ci_lower = conf.low, ci_upper = conf.high) |>
  round_df(2)

results_1_estimates

# compare marginal means
results_1_comparisons <- 
  comparisons(fit_1, contrast_factor = "pairwise") |> 
  tidy()

results_1_comparisons

# # plot
# plot_1 <- 
#   ggplot(results_1_estimates, aes(estimate, sample_size)) +
#   geom_linerange(aes(xmin = ci_lower, xmax = ci_upper)) +
#   geom_point(size = 2.5, shape = 15) +
#   scale_x_continuous(breaks = c(0, .25, .5, .75, 1), 
#                      labels = c("0.00<br/>(Worse)", "0.25", "0.50", "0.75", "1.00<br/>(Better)"),
#                      limits = c(0,1)) +
#   labs(x = "Proportion of cases where<br/>item-dropping recommendation replicated",
#        y = "N participants in each sample") +
#   mdthemes::md_theme_linedraw() 
# 
# ggsave(filename  = "../plots/plot_1.pdf",
#        plot      = plot_1,
#        device    = "pdf",
#        units     = "in",
#        width     = 5,
#        height    = 3,
#        limitsize = TRUE)

```

## Proportion of pairs of samples with matching item-drop-or-no-drop recommendation

```{r}

# fit model
fit_2 <- 
  glmer(match_item_if_dropped_or_none ~ 1 + sample_size + (1 | scale),
        family = binomial(link = "logit"),
        data = data_drop_decisions)

# marginal means
results_2_estimates <- fit_2 |>
  marginalmeans() |>
  tidy() |>
  filter(term == "sample_size") |>
  select(sample_size = value, estimate, ci_lower = conf.low, ci_upper = conf.high) |>
  round_df(2)

results_2_estimates

# compare marginal means
results_2_comparisons <- 
  comparisons(fit_2, contrast_factor = "pairwise") |> 
  tidy()

results_2_comparisons

# # plot
# plot_2 <- 
#   ggplot(results_2_estimates, aes(estimate, sample_size)) +
#   geom_linerange(aes(xmin = ci_lower, xmax = ci_upper)) +
#   geom_point(size = 2.5, shape = 15) +
#   scale_x_continuous(breaks = c(0, .25, .5, .75, 1), 
#                      labels = c("0.00<br/>(Worse)", "0.25", "0.50", "0.75", "1.00<br/>(Better)"),
#                      limits = c(0,1)) +
#   labs(x = "Proportion of cases where<br/>item-dropping recommendation replicated",
#        y = "N participants in each sample") +
#   mdthemes::md_theme_linedraw() 
# 
# ggsave(filename  = "../plots/plot_2.pdf",
#        plot      = plot_2,
#        device    = "pdf",
#        units     = "in",
#        width     = 5,
#        height    = 3,
#        limitsize = TRUE)

```

## Combined plot

```{r}

plot_replication <- 
  bind_rows(
    mutate(results_1_estimates, Strategy = "Drop one item"),
    mutate(results_2_estimates, Strategy = "Drop one item if it improves alpha compared to full scale")
  ) |>
  ggplot(aes(estimate, sample_size, color = Strategy)) +
  geom_linerange(aes(xmin = ci_lower, xmax = ci_upper), position = position_dodge(width = 0.5)) +
  geom_point(size = 2.5, shape = 15, position = position_dodge(width = 0.5)) +
  scale_color_viridis_d(begin = 0.3, end = 0.7,
                        labels = c("Drop one item",
                                   "Drop one item if it improves \u03B1 compared to full scale")) +
  scale_x_continuous(breaks = c(0, .25, .5, .75, 1), 
                     #labels = c("0.00<br/>(Worse)", "0.25", "0.50", "0.75", "1.00<br/>(Better)"),
                     labels = c("0.00", "0.25", "0.50", "0.75", "1.00"),
                     limits = c(0,1)) +
  labs(x = "Replication rate",
       y = "Sample size") +
  mdthemes::md_theme_linedraw() +
  theme(legend.position = "top") +
  guides(color = guide_legend(reverse = FALSE))

plot_replication

ggsave(filename  = "../plots/plot_replication.pdf",
       plot      = plot_replication,
       device    = cairo_pdf, # for greek letters
       units     = "in",
       width     = 6,
       height    = 4,
       limitsize = TRUE)

```

# Session info

```{r}

sessionInfo()

```

